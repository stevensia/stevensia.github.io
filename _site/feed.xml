<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Steven&#39;s Blog</title>
    <description>个人技术总结，读书笔记，心得等 | 这里是 Stevensia的个人博客，与君共勉。</description>
    <link>http://universus.cn/</link>
    <atom:link href="http://universus.cn/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 19 Jan 2016 14:03:43 +0800</pubDate>
    <lastBuildDate>Tue, 19 Jan 2016 14:03:43 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>冷静的想想，现在应该做什么</title>
        <description>
&lt;blockquote&gt;
  &lt;p&gt;最近事情很多，python零零碎碎的学习了一些东西，scrapy也是东挪西凑写了点东西抓两个网站，但是似乎这两天才搞明白Selector，也才明白这并不是我想要的，或者说我开始以为Scrapy能干的事和我想象的不一样，需要重新思考一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Scrapy的Selector是一个选择器，用scrapy发出一个请求后，Seletor就已经产生了，不管你用不用，它就在那里。那么我们能用它干嘛呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内建两个重要的方法，xpath &amp;amp; css  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内建正则表达式Re  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内建extact返回Selector对象列表，当然也可以返回字符串  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是我们用到最多的就是xpath方法了，开始我只是简单的看了一下语法，发现处理html确实很方便，于是东拼西凑的整了两个礼拜，最后我明白了，这玩意是很好用，但是有个巨大的缺陷，那就是它只能处理一组类似的元素或者属性,不能顺序处理。这是个坑爹的地方，因为很多时候我需要顺序处理，条件判断，然后获取我想要的内容，可是尼玛这是啥玩意，难道是我了解的太浅，实际上它也是能顺序处理的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;好吧，言归正传，我到底要干嘛？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实xpath这个功能已经是够够的了，不管是抓取部分数据，还是顺序处理，难道就不能获取HTML片段后再局部处理嘛？脑袋要灵活点，不能浪费时间了！&lt;/p&gt;

&lt;p&gt;所以问题的关键还是回到这里：我需要干嘛！&lt;/p&gt;

&lt;p&gt;其实我的初衷很简单，了解爬虫技术，在产生这个初衷之前我不是很了解爬虫这个概念本身最常用的功能是干嘛的，所以可能xpath这种是很准确的满足了爬虫的要求：获取部分数据，获取某个数值，例如标题，价格等数据，简单说，数据挖掘？&lt;/p&gt;

&lt;p&gt;好吧，我真的很菜：（&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么我现在需要干嘛呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;目前被卡住的： &lt;br /&gt;
1. liao网站没处理完，其中文字部分完美拿下，但是标题部分需要稍微处理一下，生成顺序标题。  &lt;br /&gt;
2. sammy网站还处在混乱中，问题在于其中包含大量图片以及推荐链接，思路如下:  &lt;/p&gt;

&lt;p&gt;顺序处理post_detail部分html代码，遇到img，下载，保存到指定目录，文档中加入图片链接；&lt;br /&gt;
  文字链接部分，如果带有a属性，用[]加入链接指示。&lt;/p&gt;

&lt;p&gt;前提都是要顺序处理，基本上xpath要被抛弃，没办法，我这是整站搬迁。。。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;那这是我不是我现在应该干的事呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好像也不是！最近python也学了快一个月了，只是进步不大，收获甚微。原因还是自己太过浮躁，一些基本问题没有弄明白，就急于求成的去平凑代码写程序，怎不知万丈高楼平地起，咱还是应该慢慢来啊。&lt;/p&gt;

&lt;p&gt;抽根烟去，回来好好反省。&lt;/p&gt;

&lt;p&gt;SMOKING…SMOKING..&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Here we go!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然xpath最适合抓取特定数据，那么咱们就来做这些事，有几个我想过的： &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;特定内容类网站的文章列表  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;微信公众号排名top50  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;监测JD/AMAZON/TMALL某商品价格列表变动，并生成价格变化曲线  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 14 Jan 2016 16:22:02 +0800</pubDate>
        <link>http://universus.cn/python/2016/01/14/thinking/</link>
        <guid isPermaLink="true">http://universus.cn/python/2016/01/14/thinking/</guid>
        
        <category>思考</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Html status code</title>
        <description>&lt;h3 id=&quot;httpcode&quot;&gt;HTTP错误code大全&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;100 - Continue
101 - Switching Protocols
Top
Success Codes
200 - OK
201 - Created
202 - Accepted
203 - Non-Authoritative Information (for DNS)
204 - No Content
205 - Reset Content
206 - Partial Content
Top
Redirection Codes
300 - Multiple Choices
301 - Moved Permanently
302 - Moved Temporarily
303 - See Other
304 - Not Modified
305 - Use Proxy
307 - Redirect Keep Verb
Top
Failure Codes
400 - Bad Request
401 - Unauthorized
402 - Payment Required
403 - Forbidden
404 - Not Found
405 - Bad Request
406 - Not Acceptable
407 - Proxy Authentication Required
408 - Request Timed-Out
409 - Conflict
410 - Gone
411 - Length Required
412 - Precondition Failed
413 - Request Entity Too Large
414 - Request, URI Too Large
415 - Unsupported Media Type
Top
Server Error Codes
500 - Internal Server Error
501 - Not Implemented
502 - Bad Gateway
503 - Server Unavailable
504 - Gateway Timed-Out
505 - HTTP Version not supported
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 23 Dec 2015 18:56:57 +0800</pubDate>
        <link>http://universus.cn/tools/2015/12/23/Html-status-code/</link>
        <guid isPermaLink="true">http://universus.cn/tools/2015/12/23/Html-status-code/</guid>
        
        
        <category>tools</category>
        
      </item>
    
      <item>
        <title>Python module paramiko</title>
        <description>
&lt;p&gt;上周学习了正则表达式， 能大概了解基本的使用，回想之前学习perl时好像对正则掌握的还可以， 可惜一年过去了， 已基本忘光， 技术这个东西， 一段时间不用真的会失忆。 这次好好学习python， 坚持用下去，毕竟有那么多能结合实际工作和生活的库可用， 而且不会像perl一样， 写过之后几天自己就看不懂了。&lt;/p&gt;

&lt;p&gt;今天写了一个ssh的程序，用的paramiko库， 网上找了一个现成的例子， 自己改了改， 记下来主要是为了不会忘记在写的过程中用到的一些语法， 毕竟还是入门阶段， 语法和标准库的不熟悉是硬伤。&lt;/p&gt;

&lt;p&gt;主要功能：&lt;br /&gt;
多线程ssh登录主机，执行hostname指令（可以自定义其他指令）， 执行成功的输出主机名和对应的IP地址，用户名，密码。&lt;/p&gt;

&lt;p&gt;下面是代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
#-*- coding: utf-8 -*-
import paramiko
import threading
import re
def ssh2(ip,username,passwd,cmd):
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(ip,22,username,passwd,timeout=5)
        for m in cmd:
            stdin, stdout, stderr = ssh.exec_command(m)
            #stdin.write(&quot;Y&quot;)   #简单交互，输入 ‘Y’
            out = stdout.readlines()
            #屏幕输出
            #for o in out:
            #    print o,
        print &#39;%-20s OK\t%-10s\t%s:%s&#39;%(ip,out[0].strip(),username,passwd)
        ssh.close()
    except:
        print &#39;%-20s Error&#39;%(ip)

if __name__==&#39;__main__&#39;:
    cmd = [&#39;hostname&#39;]#你要执行的命令列表
    threads = []   #多线程
    print &quot;Begin......&quot;
    with open(&#39;hosts&#39;,&#39;r&#39;) as HOST:
      for i in HOST:
        if re.search(r&#39;#&#39;,i):
            continue
        ip = str(i.strip(&#39;\n&#39;))
        with open(&#39;passdb&#39;,&#39;r&#39;) as FH:
          for x  in FH:
            if re.search(r&#39;#&#39;,x):
                continue
            upair=x.split()
            username=upair[0].strip(&#39;\n&#39;)
            passwd= upair[1]
            a=threading.Thread(target=ssh2,args=(ip,username,passwd,cmd))
            a.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中需要调用两个文件，用来存放主机IP地址和密码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat hosts
10.32.196.15
192.168.1.1


#cat passdb
#steven *****
steven *****
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件中#号注释内容不会被执行， 执行后输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./ssh_auto_net.py
Begin......
10.32.196.15         OK steven-laptop   steven:*********
10.32.196.15         Error
192.168.1.1          Error
192.168.1.1          Error
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 21 Dec 2015 22:19:40 +0800</pubDate>
        <link>http://universus.cn/python/2015/12/21/Python-module-paramiko/</link>
        <guid isPermaLink="true">http://universus.cn/python/2015/12/21/Python-module-paramiko/</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Learning Python encoding</title>
        <description>
&lt;p&gt;Python 字符串和编码&lt;/p&gt;

&lt;p&gt;####编码的历史问题&lt;br /&gt;
由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。&lt;/p&gt;

&lt;p&gt;但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。&lt;/p&gt;

&lt;p&gt;可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。&lt;/p&gt;

&lt;p&gt;因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。&lt;/p&gt;

&lt;p&gt;Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。&lt;/p&gt;

&lt;p&gt;如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。&lt;/p&gt;

&lt;p&gt;所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：&lt;/p&gt;

&lt;p&gt;UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;/li&gt;
  &lt;li&gt;用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。&lt;/li&gt;
  &lt;li&gt;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总之： 计算机内存中用unicode，传输或者保存到磁盘上用utf-8节省带宽和空间。&lt;/p&gt;

&lt;p&gt;####Python的字符串&lt;/p&gt;

&lt;p&gt;在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。&lt;br /&gt;
对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符。&lt;/p&gt;

&lt;p&gt;由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。&lt;/p&gt;

&lt;p&gt;要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。&lt;/p&gt;

&lt;p&gt;以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)
b&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;中文&#39;.encode(&#39;utf-8&#39;)
b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;中文&#39;.encode(&#39;ascii&#39;)
Traceback (most recent call last):
File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 0-1: ordinal not in range(128)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。&lt;/p&gt;

&lt;p&gt;在bytes中，无法显示为ASCII字符的字节，用\x##显示。&lt;/p&gt;

&lt;p&gt;反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b&#39;ABC&#39;.decode(&#39;ascii&#39;)
&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;)
&#39;中文&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。&lt;/p&gt;

&lt;p&gt;在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。&lt;/p&gt;

&lt;p&gt;由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；&lt;/p&gt;

&lt;p&gt;第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。&lt;/p&gt;

&lt;p&gt;申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码&lt;/p&gt;

</description>
        <pubDate>Sat, 12 Dec 2015 23:29:22 +0800</pubDate>
        <link>http://universus.cn/python/2015/12/12/Learning-Python-encoding/</link>
        <guid isPermaLink="true">http://universus.cn/python/2015/12/12/Learning-Python-encoding/</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Learning Python Requests [advance]</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;高级用法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-1&quot;&gt;会话对象&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;下面并不是都能理解，需要运用后再看了。尤其是每次调用的方法和请求是否都是在同一个session里面呢？&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;会话对象具有主要的Requests API的所有方法。&lt;/p&gt;

&lt;p&gt;我们来跨请求保持一些cookies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = requests.Session()

s.get(&#39;http://httpbin.org/cookies/set/sessioncookie/123456789&#39;)
r = s.get(&quot;http://httpbin.org/cookies&quot;)

print(r.text)
# &#39;{&quot;cookies&quot;: {&quot;sessioncookie&quot;: &quot;123456789&quot;}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = requests.Session()
s.auth = (&#39;user&#39;, &#39;pass&#39;)
s.headers.update({&#39;x-test&#39;: &#39;true&#39;})

# both &#39;x-test&#39; and &#39;x-test2&#39; are sent
s.get(&#39;http://httpbin.org/headers&#39;, headers={&#39;x-test2&#39;: &#39;true&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-2&quot;&gt;请求与响应对象&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任何时候调用requests.*()你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从 服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。&lt;/p&gt;

&lt;p&gt;想访问服务器返回给我们的响应头部信息，可以这样做:&lt;br /&gt;
	»&amp;gt; r.headers&lt;br /&gt;
如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部:&lt;br /&gt;
	»&amp;gt; r.request.headers&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;prepared-requests&quot;&gt;Prepared Requests&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;ssl&quot;&gt;SSL证书验证&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-3&quot;&gt;响应体内容工作流&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-4&quot;&gt;保持活动状态（持久连接）&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-5&quot;&gt;流式上传&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-6&quot;&gt;块编码请求&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;post-multiple-multipart-encoded-files&quot;&gt;POST Multiple Multipart-Encoded Files&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-7&quot;&gt;事件挂钩&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-8&quot;&gt;自定义身份验证&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-9&quot;&gt;流式请求&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-10&quot;&gt;代理&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-11&quot;&gt;合规性&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;http&quot;&gt;HTTP动词&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;section-12&quot;&gt;响应头链接字段&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;transport-adapters&quot;&gt;Transport Adapters&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;blocking-or-non-blocking&quot;&gt;Blocking Or Non-Blocking?&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;timeouts&quot;&gt;Timeouts&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;ca-certificates&quot;&gt;CA Certificates&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;身份认证&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;section-14&quot;&gt;基本身份认证&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;section-15&quot;&gt;摘要式身份认证&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;oauth-1-authentication&quot;&gt;OAuth 1 Authentication&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;section-16&quot;&gt;其他身份认证形式&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;section-17&quot;&gt;新的身份认证形式&lt;/h6&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 12 Dec 2015 23:13:27 +0800</pubDate>
        <link>http://universus.cn/python/2015/12/12/Learning-Python-Requests-%5Badvance%5D/</link>
        <guid isPermaLink="true">http://universus.cn/python/2015/12/12/Learning-Python-Requests-%5Badvance%5D/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Learning Python Requests I</title>
        <description>
&lt;p&gt;####Requests examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r=requests.get(&#39;http://10.32.196.15:4000/&#39;)
r.headers
{&#39;content-length&#39;: &#39;12913&#39;, &#39;server&#39;: &#39;WEBrick/1.3.1 (Ruby/2.0.0/2014-01-12)&#39;, &#39;last-modified&#39;: &#39;Wed, 09 Dec 2015 01:22:59 GMT&#39;, &#39;connection&#39;: &#39;Keep-Alive&#39;, &#39;etag&#39;: &#39;2c0065-3271-56678273&#39;, &#39;date&#39;: &#39;Thu, 10 Dec 2015 02:01:58 GMT&#39;, &#39;content-type&#39;: &#39;text/html&#39;}
r.encoding
&#39;ISO-8859-1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####快速上手&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;#####发送请求  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
#corp requests with BS4:
import requests
from bs4 import BeautifulSoup
import time
import json
import os
import re
session = requests.session()
req = session.get(url, headers=headers)
soup = BeautifulSoup(req.text, &quot;html.parser&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么其他HTTP请求类型：PUT， DELETE， HEAD以及OPTIONS又是如何的呢？都是一样的简单:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = requests.put(&quot;http://httpbin.org/put&quot;)
r = requests.delete(&quot;http://httpbin.org/delete&quot;)
r = requests.head(&quot;http://httpbin.org/get&quot;)
r = requests.options(&quot;http://httpbin.org/get&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####为URL传递参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如， &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;httpbin.org/get?key=val  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Requests允许你使用 params 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;payload = {&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;}
r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)
print (r.url)
http://httpbin.org/get?key2=value2&amp;amp;key1=value1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####响应内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = requests.get(&#39;https://github.com/timeline.json&#39;)
r.text
u&#39;{&quot;message&quot;:&quot;Hello there, wayfaring stranger. If you\u2019re reading this then you probably didn\u2019t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.&quot;,&quot;documentation_url&quot;:&quot;https://developer.github.com/v3/activity/events/#list-public-events&quot;}&#39;
r.content
&#39;{&quot;message&quot;:&quot;Hello there, wayfaring stranger. If you\xe2\x80\x99re reading this then you probably didn\xe2\x80\x99t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.&quot;,&quot;documentation_url&quot;:&quot;https://developer.github.com/v3/activity/events/#list-public-events&quot;}&#39;
r.encoding
&#39;utf-8&#39;
r.encoding = &#39;ISO-8859-1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####二进制响应内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你也能以字节的方式访问请求响应体，对于非文本请求:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.content
b&#39;[{&quot;repository&quot;:{&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Requests会自动为你解码 gzip 和 deflate 传输编码的响应数据。&lt;/p&gt;

&lt;p&gt;例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from PIL import Image
from StringIO import StringIO
i = Image.open(StringIO(r.content))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####JSON响应内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Requests中也有一个内置的JSON解码器，助你处理JSON数据:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import requests
r = requests.get(&#39;https://github.com/timeline.json&#39;)
r.json()
[{u&#39;repository&#39;: {u&#39;open_issues&#39;: 0, u&#39;url&#39;: &#39;https://github.com/...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果JSON解码失败， r.json 就会抛出一个异常。例如，相应内容是 401 (Unauthorized) ，尝试访问 r.json 将会抛出 ValueError: No JSON object could be decoded 异常。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;#####原始响应内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw 。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True 。具体的你可以这么做:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = requests.get(&#39;https://github.com/timeline.json&#39;, stream=True)
r.raw
&amp;lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&amp;gt;
r.raw.read(10)
&#39;\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但一般情况下，你应该下面的模式将文本流保存到文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(filename, &#39;wb&#39;) as fd:
	for chunk in r.iter_content(chunk_size):
		fd.write(chunk)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####定制请求头&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。&lt;/p&gt;

&lt;p&gt;很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict ，那么数据会被直接发布出去。&lt;br /&gt;
例如，在前一个示例中我们没有指定content-type:&lt;/p&gt;

&lt;p&gt;例如，Github API v3接受编码为JSON的POST/PATCH数据:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import json
url = &#39;https://api.github.com/some/endpoint&#39;
payload = {&#39;some&#39;: &#39;data&#39;}
headers = {&#39;content-type&#39;: &#39;application/json&#39;}

r = requests.post(url, data=json.dumps(payload), headers=headers)
r.text
u&#39;{&quot;message&quot;:&quot;Not Found&quot;,&quot;documentation_url&quot;:&quot;https://developer.github.com/v3&quot;}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####更加复杂的POST请求    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is an example:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;headers = {
&quot;User-Agent&quot;: &#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/45.0.2454.101 Chrome/45.0.2454.101 Safari/537.36&#39;,
}
r = requests.post(&quot;http://httpbin.org/post&quot;, data=payload, headers=headerr )
print  (r.text)
{
&quot;args&quot;: {},
&quot;data&quot;: &quot;&quot;,
&quot;files&quot;: {},
&quot;form&quot;: {
	&quot;key1&quot;: &quot;value1&quot;,
	&quot;key2&quot;: &quot;value2&quot;
},
&quot;headers&quot;: {
	&quot;Accept&quot;: &quot;*/*&quot;,
	&quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,
	&quot;Content-Length&quot;: &quot;23&quot;,
	&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,
	&quot;Host&quot;: &quot;httpbin.org&quot;,
	&quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/45.0.2454.101 Chrome/45.0.2454.101 Safari/537.36&quot;,
	&quot;X-Imforwards&quot;: &quot;20&quot;
},
&quot;json&quot;: null,
&quot;origin&quot;: &quot;168.159.144.56&quot;,
&quot;url&quot;: &quot;http://httpbin.org/post&quot;
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####POST一个多部分编码(Multipart-Encoded)的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Requests使得上传多部分编码文件变得很简单;&lt;br /&gt;
你可以显式地设置文件名，文件类型和请求头;&lt;br /&gt;
如果你想，你也可以发送作为文件来接收的字符串’&lt;br /&gt;
在一个请求中发送多文件参考 &lt;a href=&quot;http://cn.python-requests.org/zh_CN/latest/user/advanced.html#advanced&quot;&gt;高级用法 一节&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;#####响应状态码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Simple example: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = requests.get(&#39;http://httpbin.org/get&#39;)
r.status_code
200
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####响应头&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以查看以一个Python字典形式展示的服务器响应头:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.headers
{
	&#39;content-encoding&#39;: &#39;gzip&#39;,
	&#39;transfer-encoding&#39;: &#39;chunked&#39;,
	&#39;connection&#39;: &#39;close&#39;,
	&#39;server&#39;: &#39;nginx/1.0.4&#39;,
	&#39;x-runtime&#39;: &#39;148ms&#39;,
	&#39;etag&#39;: &#39;&quot;e1ca502697e5c9317743dc078f67693f&quot;&#39;,
	&#39;content-type&#39;: &#39;application/json&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。&lt;/p&gt;

&lt;p&gt;因此，我们可以使用任意大写形式来访问这些响应头字段:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; r.headers[&#39;Content-Type&#39;]
&#39;application/json&#39;

&amp;gt;&amp;gt;&amp;gt; r.headers.get(&#39;content-type&#39;)
&#39;application/json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;#####&lt;strong&gt;Cookies&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果某个响应中包含一些Cookie，你可以快速访问它们:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url = &#39;http://example.com/some/cookie/setting/url&#39;
r = requests.get(url)

r.cookies[&#39;example_cookie_name&#39;]
&#39;example_cookie_value&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要想发送你的cookies到服务器，可以使用 cookies 参数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url = &#39;http://httpbin.org/cookies&#39;
cookies = dict(cookies_are=&#39;working&#39;)

r = requests.get(url, cookies=cookies)
r.text
&#39;{&quot;cookies&quot;: {&quot;cookies_are&quot;: &quot;working&quot;}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;#####重定向与请求历史&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;#####超时&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过以 timeout 参数设定的秒数时间之后停止等待响应&lt;br /&gt;
	requests.get(‘http://github.com’, timeout=0.001)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;#####错误与异常&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Dec 2015 15:22:47 +0800</pubDate>
        <link>http://universus.cn/python/2015/12/11/Learning-Python-Requests-I/</link>
        <guid isPermaLink="true">http://universus.cn/python/2015/12/11/Learning-Python-Requests-I/</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Learning Python BeautifulSoup</title>
        <description>&lt;h4 id=&quot;soup-examples&quot;&gt;Soup examples:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;for i in soup.find_all(&#39;body&#39;):print (i)  
for i in soup.find_all(re.compile(&#39;^body&#39;)):print (i)  
for i in soup.find_all(re.compile(&#39;^t&#39;)):print (i.name)  
for i in soup.find_all([&quot;title&quot;,&quot;body&quot;]):print (i.name)  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;基本上来说， BeautifulSoup是一个用来解析或者转换html格式文件的python库，功能十分强大，在学习过程中能了解到html的一些基础知识，上面的几个例子是find_all方法的 一些示例，按照tag，正则打印出搜索到的内容，十分有用。  &lt;br /&gt;
&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html&quot;&gt;文档&lt;/a&gt;很快的过了一遍，大概的了解一下结构， 只是暂时还不能用到特别多的功能，暂且放下，等后面需要解析文档或者转换文档的时候再回来仔细看一遍，继续补充这篇文档。  &lt;br /&gt;
接下来要研究Requests 。  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Another CN BS4 guide is &lt;a href=&quot;http://cuiqingcai.com/1319.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Come on!!!&lt;/p&gt;

</description>
        <pubDate>Fri, 11 Dec 2015 15:18:03 +0800</pubDate>
        <link>http://universus.cn/python/2015/12/11/Learning-Python-BeautifulSoup/</link>
        <guid isPermaLink="true">http://universus.cn/python/2015/12/11/Learning-Python-BeautifulSoup/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Markdown在Notepad++中的使用体验</title>
        <description>
&lt;p&gt;Notepad++本身除了作为一款强大的编辑器外，主要魅力还有由NPP社区和开发人员贡献的种类众多的插件，这些插件几乎可以满足我们各种各样的需求，解决大大小小的问题。找到适合自己的插件，并且灵活使用，将有效提高我们的开发和写作效率。&lt;/p&gt;

&lt;p&gt;Notepad++安装插件的两个方法：一个是通过软件自带的Plugin Manager来查找可用插件，勾选安装；还有个就是直接下载插件的dll文件，复制到Notepad++安装目录的plugins目录下，再重启软件即可。&lt;/p&gt;

&lt;p&gt;Markdown作为一种日渐流行的轻量级标记语言，日常使用自然是少不了的，而到目前为止，Notepad++上还没有一个称得上完美的方法来支持Markdown，只能自己动手改善，这里总结目前找到的优化Markdown在Notepad++中使用体验的两个方面。&lt;/p&gt;

&lt;p&gt;####第一、实现Markdown语法高亮&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;首先下载Markdown规则文件，然后可以通过Notepad++中的 语言 -&amp;gt; 自定义语言格式 -&amp;gt; 导入 来实现；也可以通过手动操作实现，点击 开始菜单 -&amp;gt; 运行(或者直接按 Win+R) -&amp;gt; 输入 %APPDATA%\Notepad++，将userDefineLang.xml放置到此目录（如果已有同名文件存在，则将下载文件的内容增加进去，方法参考&lt;a href=&quot;https://github.com/Edditoria/markdown_npp_zenburn&quot;&gt;这里&lt;/a&gt;，重启软件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/22576-b7b2c862397842c0.jpg?imageMogr2/auto-orient/strip%257CimageView2/2/w/1240&quot; alt=&quot;示例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####第二、实现Markdown实时预览&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这个比较简单，看这篇文章&lt;a href=&quot;http://blog.gclxry.com/%25E5%2586%2599%25E4%25BA%2586%25E4%25B8%2580%25E4%25B8%25AAnotepad%25E7%259A%2584markdown%25E6%258F%2592%25E4%25BB%25B6/&quot;&gt;写了一个Notepad++的markdown插件&lt;/a&gt;，下载里面的NppMarkdown插件（也可以下载我备份在百度云的），复制dll到Notepad++安装目录的plugins目录下，重启软件。&lt;br /&gt;
&lt;a href=&quot;http://pan.baidu.com/s/1c08pOjQ&quot;&gt;Download&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/22576-b63f4097ad8559ea.jpg?imageMogr2/auto-orient/strip%257CimageView2/2/w/1240&quot; alt=&quot;pic2&quot; /&gt;  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小提示&lt;/strong&gt;：Notepad++的AutoSave插件和多列编辑功能（菜单栏 -&amp;gt; 设置 -&amp;gt; 首选项 -&amp;gt; 编辑，勾上右边“多列编辑”的小框）都不错哦。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文在&lt;a href=&quot;http://xuhehuan.com/2237.html&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 06 Dec 2015 04:14:14 +0800</pubDate>
        <link>http://universus.cn/tools/2015/12/06/Markdown-notepad/</link>
        <guid isPermaLink="true">http://universus.cn/tools/2015/12/06/Markdown-notepad/</guid>
        
        
        <category>tools</category>
        
      </item>
    
      <item>
        <title>Git configuration</title>
        <description>
&lt;p&gt;###Before&lt;br /&gt;
最近学习了一点GIT的知识，用起来也很方便，这篇文章是用来记录一些常用的命令和配置，后续有新的知识点会更新进来。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;####Git alias config&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can find below tips from &lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000&quot;&gt;here&lt;/a&gt;   &lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.br branch
git config --global alias.last &#39;log -1&#39;
git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&#39; --abbrev-commit&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;####Git password cache setting  &lt;br /&gt;
We can make git store password in cache, then stop keeping input password for every git push.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
git config --global credential.helper cache  
#Set git to use the credential memory cache**  

git config --global credential.helper &#39;cache --timeout=3600&#39;
# Set the cache to timeout after 1 hour (setting is in seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is where I found this &lt;a href=&quot;https://help.github.com/articles/caching-your-github-password-in-git/#platform-linux&quot;&gt;setting&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 05 Dec 2015 21:08:47 +0800</pubDate>
        <link>http://universus.cn/tools/2015/12/05/Git-configuration/</link>
        <guid isPermaLink="true">http://universus.cn/tools/2015/12/05/Git-configuration/</guid>
        
        
        <category>tools</category>
        
      </item>
    
      <item>
        <title>Linux bash environment setting and bashrc file</title>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;Before&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
关于Linux下的bash环境问题一直没搞明白，今天在自己的系统中加了个用户，然后copy了.bashrc到home目录下，结果不生效。  &lt;br /&gt;
网上找了些文档整理出来。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;启动过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在登录Linux时要执行文件的过程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
/etc/profile -&amp;gt; (~/.bash_profile | ~/.bash_login | ~/.profile) -&amp;gt; 
     ~/.bashrc -&amp;gt; /etc/bashrc -&amp;gt; ~/.bash_logout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在刚登录Linux时:  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先启动 /etc/profile 文件;  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后再启动用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件中的其中一个，&lt;/p&gt;

    &lt;p&gt;如果 ~/.bash_profile文件存在的话,一般还会执行 ~/.bashrc文件。&lt;/p&gt;

    &lt;p&gt;因为:&lt;br /&gt;
  ~/.bash_profile文件中一般会有下面的代码：&lt;br /&gt;
 if [ -f ~/.bashrc ] ; then&lt;br /&gt;
 . ./bashrc&lt;br /&gt;
 fi&lt;/p&gt;

    &lt;p&gt;~/.bashrc中，一般还会有以下代码：&lt;br /&gt;
 if [ -f /etc/bashrc ] ; then&lt;br /&gt;
 . /bashrc&lt;br /&gt;
 fi&lt;/p&gt;

    &lt;p&gt;所以，~/.bashrc会调用 /etc/bashrc文件。 &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，在退出shell时，还会执行 ~/.bash_logout文件。  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件 任何一个存在，而其中没有load其他配置文件，那么加载终止。  &lt;br /&gt;
Ubuntu默认只包含/etc/profile, ~/.profile, ~/.bashrc, 其中~/.profile 中包含加载~/.bashrc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;文件说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;/etc/profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.  &lt;br /&gt;
/etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。  &lt;br /&gt;
~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下)  &lt;br /&gt;
~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/.bash_profile&lt;/strong&gt; 是交互式、login 方式进入 bash 运行的  &lt;br /&gt;
每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.  &lt;br /&gt;
&lt;strong&gt;~/.bashrc&lt;/strong&gt; 是交互式 non-login 方式进入 bash 运行的   &lt;br /&gt;
该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。   &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通常二者设置大致相同，所以通常前者会调用后者。××&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;br /&gt;
网上看到一个比较全的设置&lt;a href=&quot;http://blog.csdn.net/bangemantou/article/details/7682272&quot;&gt;示例&lt;/a&gt;，之前从来没认真研究过，等空下来再好好看看。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考： &lt;a href=&quot;http://my.oschina.net/wxfvm/blog/332726&quot;&gt;linux中.bashrc文件&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 05 Dec 2015 20:15:22 +0800</pubDate>
        <link>http://universus.cn/linux/2015/12/05/Linux-bash-environment-setting-and-bashrc-file/</link>
        <guid isPermaLink="true">http://universus.cn/linux/2015/12/05/Linux-bash-environment-setting-and-bashrc-file/</guid>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
  </channel>
</rss>
